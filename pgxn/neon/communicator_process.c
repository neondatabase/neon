/*-------------------------------------------------------------------------
 *
 * communicator_process.c
 *	  Functions for starting up the communicator background worker process.
 *
 * Currently, the communicator process only functions as a metrics
 * exporter. It provides an HTTP endpoint for polling a limited set of
 * metrics. TODO: In the future, it will do much more, i.e. handle all
 * the communications with the pageservers.
 *
 * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *-------------------------------------------------------------------------
 */
#include "postgres.h"

#include <unistd.h>

#include "miscadmin.h"
#include "postmaster/bgworker.h"
#include "postmaster/interrupt.h"
#include "postmaster/postmaster.h"
#include "replication/walsender.h"
#include "storage/ipc.h"
#include "storage/latch.h"
#include "storage/pmsignal.h"
#include "storage/procsignal.h"
#include "tcop/tcopprot.h"

#include "communicator_process.h"
#include "file_cache.h"
#include "neon.h"
#include "neon_perf_counters.h"

/* the rust bindings, generated by cbindgen */
#include "communicator/communicator_bindings.h"

PGDLLEXPORT void communicator_new_bgworker_main(Datum main_arg);

/**** Initialization functions. These run in postmaster ****/

void
register_communicator_bgworker(void)
{
	BackgroundWorker bgw;

	/* Initialize the background worker process */
	memset(&bgw, 0, sizeof(bgw));
	bgw.bgw_flags = BGWORKER_SHMEM_ACCESS;
	bgw.bgw_start_time = BgWorkerStart_PostmasterStart;
	snprintf(bgw.bgw_library_name, BGW_MAXLEN, "neon");
	snprintf(bgw.bgw_function_name, BGW_MAXLEN, "communicator_new_bgworker_main");
	snprintf(bgw.bgw_name, BGW_MAXLEN, "Storage communicator process");
	snprintf(bgw.bgw_type, BGW_MAXLEN, "Storage communicator process");
	bgw.bgw_restart_time = 5;
	bgw.bgw_notify_pid = 0;
	bgw.bgw_main_arg = (Datum) 0;

	RegisterBackgroundWorker(&bgw);
}

/**** Worker process functions. These run in the communicator worker process ****/

/* Entry point for the communicator bgworker process */
void
communicator_new_bgworker_main(Datum main_arg)
{
	struct LoggingState *logging;
	char		errbuf[1000];
	int			elevel;
	const struct CommunicatorWorkerProcessStruct *proc_handle;

	/*
	 * Pretend that this process is a WAL sender. That affects the shutdown
	 * sequence: WAL senders are shut down last, after the final checkpoint
	 * has been written. That's what we want for the communicator process too.
	 */
	am_walsender = true;
	MarkPostmasterChildWalSender();

	/* Establish signal handlers. */
	pqsignal(SIGUSR1, procsignal_sigusr1_handler);
	/*
	 * Postmaster sends us SIGUSR2 when all regular backends and bgworkers
	 * have exited, and it's time for us to exit too
	 */
	pqsignal(SIGUSR2, die);
	pqsignal(SIGHUP, SignalHandlerForConfigReload);
	pqsignal(SIGTERM, die);

	BackgroundWorkerUnblockSignals();

	logging = configure_logging();

	proc_handle = communicator_worker_process_launch(
		neon_tenant[0] == '\0' ? NULL : neon_tenant,
		neon_timeline[0] == '\0' ? NULL : neon_timeline
		);

	/* proc_handle is not currently used, but will be in the future */
	(void) proc_handle;

	/*
	 * The Rust tokio runtime has been launched, and it's running in the
	 * background now. This process is now multi-threaded! The Rust threads do
	 * not call into any Postgres functions.
	 *
	 * This loop in the main thread handles any interactions we need with the
	 * rest of PostgreSQL.
	 */
	elog(LOG, "communicator threads started");
	for (;;)
	{
		int32		rc;

		/*
		 * Check interrupts like system shutdown or config reload
		 */
		CHECK_FOR_INTERRUPTS();
		if (ConfigReloadPending)
		{
			ConfigReloadPending = false;
			ProcessConfigFile(PGC_SIGHUP);
		}

		/*
		 * Forward any log messages from the Rust threads into the normal Postgres
		 * logging facility.
		 */
		for (;;)
		{
			rc = pump_logging(logging, (uint8 *) errbuf, sizeof(errbuf), &elevel);
			if (rc == 0)
			{
				/* nothing to do */
				break;
			}
			else if (rc == 1)
			{
				/* Because we don't want to exit on error */
				if (elevel == ERROR)
					elevel = LOG;
				if (elevel == INFO)
					elevel = LOG;
				elog(elevel, "[COMMUNICATOR] %s", errbuf);
			}
			else if (rc == -1)
			{
				elog(ERROR, "logging channel was closed unexpectedly");
			}
		}

		/*
		 * Wait until we are woken up. The rust threads will set the latch if
		 * there's log message to forward.
		 */
		(void) WaitLatch(MyLatch,
						 WL_LATCH_SET | WL_EXIT_ON_PM_DEATH,
						 0,
						 PG_WAIT_EXTENSION);
		ResetLatch(MyLatch);
	}
}

/****
 * Callbacks from the rust code, in the communicator process.
 *
 * NOTE: These must be thread-safe! It's very limited which PostgreSQL
 * functions you can use!!!
 *
 * The signatures of these need to match those in the Rust code.
 */

void
callback_set_my_latch_unsafe(void)
{
	SetLatch(MyLatch);
}
