/*-------------------------------------------------------------------------
 *
 * communicator_new.c
 *	  Functions for communicating with remote pageservers.
 *
 * This is the "new" communicator. It consists of functions that
 * are called from the smgr implementation, in pagestore_smgr.c.
 *
 * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *-------------------------------------------------------------------------
 */
#include "postgres.h"

#include "access/xlog.h"
#include "access/xlogdefs.h"
#include "access/xlog_internal.h"
#include "access/xlogutils.h"
#include "executor/instrument.h"
#include "miscadmin.h"
#include "postmaster/bgworker.h"
#include "postmaster/interrupt.h"
#include "replication/walsender.h"
#include "storage/latch.h"
#include "storage/procarray.h"
#if PG_VERSION_NUM >= 170000
#include "storage/procnumber.h"
#endif
#include "storage/spin.h"
#include "tcop/tcopprot.h"

#include "bitmap.h"
#include "communicator_new.h"
#include "neon.h"
#include "neon_perf_counters.h"
#include "pagestore_client.h"

/* the rust bindings, generated by cbindgen */
#include "communicator/communicator_bindings.h"

static CommunicatorInitStruct *cis;
static CommunicatorBackendStruct *my_bs;

static slock_t in_elog;

PGDLLEXPORT void communicator_new_bgworker_main(Datum main_arg);

/**** Initialization functions. These run in postmaster ****/

void
pg_init_communicator_new(void)
{
	BackgroundWorker bgw;

	/* Initialize the background worker process */
	memset(&bgw, 0, sizeof(bgw));
	bgw.bgw_flags = BGWORKER_SHMEM_ACCESS;
	bgw.bgw_start_time = BgWorkerStart_PostmasterStart;
	snprintf(bgw.bgw_library_name, BGW_MAXLEN, "neon");
	snprintf(bgw.bgw_function_name, BGW_MAXLEN, "communicator_new_bgworker_main");
	snprintf(bgw.bgw_name, BGW_MAXLEN, "Storage communicator process");
	snprintf(bgw.bgw_type, BGW_MAXLEN, "Storage communicator process");
	bgw.bgw_restart_time = 5;
	bgw.bgw_notify_pid = 0;
	bgw.bgw_main_arg = (Datum) 0;

	RegisterBackgroundWorker(&bgw);

	SpinLockInit(&in_elog);
}

void
communicator_new_shmem_request(void)
{
	size_t		size;

	size = rcommunicator_shmem_size(MaxBackends);
	RequestAddinShmemSpace(size);
}

void
communicator_new_shmem_startup(void)
{
	bool		found;
	int			pipefd[2];
	int			rc;
	size_t		shmem_size;
	void	   *shmem_ptr;

	rc = pipe(pipefd);
	if (rc != 0)
		ereport(ERROR,
				(errcode_for_file_access(),
				 errmsg_internal("could not create pipe between neon communicator and backends : %m")));
	if (fcntl(pipefd[0], F_SETFL, O_NONBLOCK) == -1)
		elog(FATAL, "fcntl(F_SETFL) failed on read-end of communicator pipe: %m");
	if (fcntl(pipefd[1], F_SETFL, O_NONBLOCK) == -1)
		elog(FATAL, "fcntl(F_SETFL) failed on write-end of communicator pipe: %m");

	shmem_size = rcommunicator_shmem_size(MaxBackends);

	shmem_ptr = ShmemInitStruct("Communicator shmem state",
								shmem_size,
								&found);
	Assert(!found);

	cis = rcommunicator_shmem_init(pipefd[0], pipefd[1], MaxBackends, shmem_ptr, shmem_size);
}

/**** Worker process functions. These run in the communicator worker process ****/

/* Entry point for the communicator bgworker process */
void
communicator_new_bgworker_main(Datum main_arg)
{
	char	  **connstrs;
	shardno_t	num_shards;
	struct LoggingState *logging;
	char		errbuf[1000];
	int			elevel;

	/* Establish signal handlers. */
	pqsignal(SIGUSR1, procsignal_sigusr1_handler);
	pqsignal(SIGHUP, SignalHandlerForConfigReload);
	pqsignal(SIGTERM, die);

	BackgroundWorkerUnblockSignals();

	get_shard_map(&connstrs, &num_shards);

	logging = configure_logging();

	communicator_worker_process_launch(
		cis,
		neon_tenant,
		neon_timeline,
		neon_auth_token,
		connstrs,
		num_shards
		);

	elog(LOG, "communicator threads started");
	for (;;)
	{
		int32		rc;

		CHECK_FOR_INTERRUPTS();

		for (;;) {
			rc = pump_logging(logging, (uint8 *) errbuf, sizeof(errbuf), &elevel);
			if (rc == 0)
			{
				/* nothing to do */
				break;
			}
			else if (rc == 1)
			{
				/* Because we don't want to exit on error */
				if (elevel == ERROR)
					elevel = LOG;
				if (elevel == INFO)
					elevel = LOG;
				elog(elevel, "[COMMUNICATOR] %s", errbuf);
			}
			else if (rc == -1)
			{
				elog(ERROR, "logging channel was closed unexpectedly");
			}
		}

		(void) WaitLatch(MyLatch,
						 WL_LATCH_SET | WL_EXIT_ON_PM_DEATH,
						 0,
						 PG_WAIT_EXTENSION);
		ResetLatch(MyLatch);
	}
}

/*
 * Callbacks from the rust code, in the communicator process.
 *
 * NOTE: These must be thread safe! It's very limited which PostgreSQL functions you can use!!!
 *
 * NOTE: the signatures of these better match the Rust definitions!
 */

void
notify_proc_unsafe(int procno)
{
	PGPROC	   *proc;

	proc = GetPGProcByNumber(procno);
	SetLatch(&proc->procLatch);
}

void
callback_set_my_latch_unsafe(void)
{
	SetLatch(MyLatch);
}

/**** Backend functions. These run in each backend ****/

/* Initialize per-backend private state */
void
communicator_new_init(void)
{
#if PG_VERSION_NUM < 170000
	int			MyProcNumber = (MyProc - &ProcGlobal->allProcs[0]);
#endif

	Assert(cis != NULL);
	Assert(my_bs == NULL);

	my_bs = rcommunicator_backend_init(cis, MyProcNumber);
}

/*
 * Lookup of already received prefetch requests. Only already received
 * responses matching required LSNs are accepted.  Present pages are marked in
 * "mask" bitmap and total number of such pages is returned.
 */
int
communicator_new_prefetch_lookupv(NRelFileInfo rinfo, ForkNumber forkNum, BlockNumber blocknum,
								  neon_request_lsns *lsns, BlockNumber nblocks,
								  void **buffers, bits8 *mask)
{
	/* TODO */
	return 0;
}

/*
 * prefetch_register_bufferv() - register and prefetch buffers
 *
 * Register that we may want the contents of BufferTag in the near future.
 * This is used when issuing a speculative prefetch request, but also when
 * performing a synchronous request and need the buffer right now.
 *
 * If force_request_lsns is not NULL, those values are sent to the
 * pageserver. If NULL, we utilize the lastWrittenLsn -infrastructure
 * to calculate the LSNs to send.
 *
 * Bits set in *mask (if present) indicate pages already read; i.e. pages we
 * can skip in this process.
 *
 * When performing a prefetch rather than a synchronous request,
 * is_prefetch==true. Currently, it only affects how the request is accounted
 * in the perf counters.
 *
 * NOTE: this function may indirectly update MyPState->pfs_hash; which
 * invalidates any active pointers into the hash table.
 */
void
communicator_new_prefetch_register_bufferv(BufferTag tag, neon_request_lsns *frlsns,
										   BlockNumber nblocks, const bits8 *mask)
{
	/* TODO */
	elog(LOG, "communicator_new_prefetch_register_bufferv not implemented");
}

/*
 * Perform an IO request in a synchronous fashion.
 *
 * Returns a pointer to the result slot. It is valid until the next time a
 * request is submitted.
 */
static const NeonIOResult *
perform_request(NeonIORequest *request)
{
	int32_t		request_idx;
	int32_t		poll_res;
	const NeonIOResult *result;

	for (;;)
	{
		ResetLatch(MyLatch);

		CHECK_FOR_INTERRUPTS();

		request_idx = bcomm_start_io_request(my_bs, request);
		// fixme: check 'request_idx' ?

		elog(DEBUG5, "sent request with idx %d: tag %d", request_idx, request->tag);

		(void) WaitLatch(MyLatch,
						 WL_EXIT_ON_PM_DEATH | WL_LATCH_SET,
						 0,
						 WAIT_EVENT_NEON_PS_STARTING);

		poll_res = bcomm_poll_request_completion(my_bs, request_idx, &result);
		if (poll_res == -1)
			continue; /* still busy */
		else if (poll_res == 0)
			return result;
		else
		{
			// FIXME: better error message
			elog(ERROR, "request failed");
		}
	}
}

/*
 *	Does the physical file exist?
 */
bool
communicator_new_rel_exists(NRelFileInfo rinfo, ForkNumber forkNum, neon_request_lsns *request_lsns)
{
	NeonIORequest request = {
		.tag = NeonIORequest_RelExists,
		.rel_exists = {
			.spc_oid = NInfoGetSpcOid(rinfo),
			.db_oid = NInfoGetDbOid(rinfo),
			.rel_number = NInfoGetRelNumber(rinfo),
			.fork_number = forkNum,
			.request_lsn = request_lsns->request_lsn,
			.not_modified_since_lsn = request_lsns->not_modified_since,
		}
	};
	const NeonIOResult *result;

	result = perform_request(&request);
	Assert(result->tag == NeonIOResult_RelExists);

	return result->rel_exists;
}

static void
communicator_new_read_at_lsn(NRelFileInfo rinfo, ForkNumber forkNum, BlockNumber blockno,
							  neon_request_lsns *request_lsns,
							  void *buffer)
{
	/*
	 * FIXME: if 'buffer' points to local memory rather than a shared memory
	 * area, we need a different way of getting the result from the
	 * communicator.
	 */

	NeonIORequest request = {
		.tag = NeonIORequest_GetPage,
		.get_page = {
			.spc_oid = NInfoGetSpcOid(rinfo),
			.db_oid = NInfoGetDbOid(rinfo),
			.rel_number = NInfoGetRelNumber(rinfo),
			.fork_number = forkNum,
			.block_number = blockno,
			.request_lsn = request_lsns->request_lsn,
			.not_modified_since = request_lsns->not_modified_since,
			.dest_ptr = (uintptr_t) buffer,
			.dest_size = BLCKSZ,
		}
	};
	const NeonIOResult *result;

	result = perform_request(&request);
	Assert(result->tag == NeonIOResult_GetPage);
}

/*
 * Read N pages at a specific LSN.
 *
 * *mask is set for pages read at a previous point in time, and which we
 * should not touch, nor overwrite.
 * New bits should be set in *mask for the pages we'successfully read.
 *
 * The offsets in request_lsns, buffers, and mask are linked.
 */
void
communicator_new_read_at_lsnv(NRelFileInfo rinfo, ForkNumber forkNum, BlockNumber base_blockno,
							  neon_request_lsns *request_lsnsv,
							  void **buffers, BlockNumber nblocks, const bits8 *mask)
{
	for (uint32 i = 0; i < nblocks; i++)
	{
		if (PointerIsValid(mask) && !BITMAP_ISSET(mask, i))
			continue;

		communicator_new_read_at_lsn(rinfo,
									 forkNum,
									 base_blockno + i,
									 &request_lsnsv[i],
									 buffers[i]);
	}
}




/*
 *	neon_nblocks() -- Get the number of blocks stored in a relation.
 */
BlockNumber
communicator_new_rel_nblocks(NRelFileInfo rinfo, ForkNumber forkNum, neon_request_lsns *request_lsns)
{
	NeonIORequest request = {
		.tag = NeonIORequest_RelSize,
		.rel_size = {
			.spc_oid = NInfoGetSpcOid(rinfo),
			.db_oid = NInfoGetDbOid(rinfo),
			.rel_number = NInfoGetRelNumber(rinfo),
			.fork_number = forkNum,
			.request_lsn = request_lsns->request_lsn,
			.not_modified_since = request_lsns->not_modified_since,
		}
	};
	const NeonIOResult *result;

	result = perform_request(&request);
	Assert(result->tag == NeonIOResult_RelSize);

	return result->rel_size;
}

/*
 *	neon_db_size() -- Get the size of the database in bytes.
 */
int64
communicator_new_dbsize(Oid dbNode, neon_request_lsns *request_lsns)
{
	NeonIORequest request = {
		.tag = NeonIORequest_DbSize,
		.db_size = {
			.db_oid = dbNode,
			.request_lsn = request_lsns->request_lsn,
			.not_modified_since = request_lsns->not_modified_since,
		}
	};
	const NeonIOResult *result;

	result = perform_request(&request);
	Assert(result->tag == NeonIOResult_DbSize);

	return (int64) result->db_size;
}

int
communicator_new_read_slru_segment(SlruKind kind, int64 segno, neon_request_lsns *request_lsns,
								   void *buffer)
{
	/* TODO */
	elog(ERROR, "not implemented");
}
