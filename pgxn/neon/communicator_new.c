/*-------------------------------------------------------------------------
 *
 * communicator_new.c
 *	  Functions for communicating with remote pageservers.
 *
 * This is the "new" communicator. It consists of functions that
 * are called from the smgr implementation, in pagestore_smgr.c.
 *
 * Portions Copyright (c) 1996-2021, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *-------------------------------------------------------------------------
 */
#include "postgres.h"

#include "access/xlog.h"
#include "access/xlogdefs.h"
#include "access/xlog_internal.h"
#include "access/xlogutils.h"
#include "executor/instrument.h"
#include "miscadmin.h"
#include "postmaster/bgworker.h"
#include "postmaster/interrupt.h"
#include "replication/walsender.h"
#include "storage/ipc.h"
#include "storage/latch.h"
#include "storage/procarray.h"
#if PG_VERSION_NUM >= 170000
#include "storage/procnumber.h"
#endif
#include "storage/spin.h"
#include "tcop/tcopprot.h"

#include "bitmap.h"
#include "communicator_new.h"
#include "neon.h"
#include "neon_perf_counters.h"
#include "pagestore_client.h"

/* the rust bindings, generated by cbindgen */
#include "communicator/communicator_bindings.h"

#define MaxProcs (MaxBackends + NUM_AUXILIARY_PROCS)

static CommunicatorInitStruct *cis;
static CommunicatorBackendStruct *my_bs;

typedef struct CommunicatorShmemData {
	int			dummy;

	/*
	 * Latches used to notify backends of IO completion. We cannot use the
	 * standard process latch (MyProc->latch) because we cannot clear that
	 * latch as part of the IO handling, or we might cause the caller to miss
	 * some other events.
	 *
	 * FIXME: These should probably be padded to cache line, to avoid false
	 * sharing and bouncing the cache lines between processes
	 */
	Latch		io_completion_latches[];	/* MaxProcs */

	/* rust-managed shmem area follows at next MAXALIGN boundary */
} CommunicatorShmemData;

static CommunicatorShmemData *communicator_shmem_ptr;

#define MyIOCompletionLatch (&communicator_shmem_ptr->io_completion_latches[MyProcNumber])

static slock_t in_elog;

PGDLLEXPORT void communicator_new_bgworker_main(Datum main_arg);
static void communicator_new_backend_exit(int code, Datum arg);

/**** Initialization functions. These run in postmaster ****/

void
pg_init_communicator_new(void)
{
	BackgroundWorker bgw;

	/* Initialize the background worker process */
	memset(&bgw, 0, sizeof(bgw));
	bgw.bgw_flags = BGWORKER_SHMEM_ACCESS;
	bgw.bgw_start_time = BgWorkerStart_PostmasterStart;
	snprintf(bgw.bgw_library_name, BGW_MAXLEN, "neon");
	snprintf(bgw.bgw_function_name, BGW_MAXLEN, "communicator_new_bgworker_main");
	snprintf(bgw.bgw_name, BGW_MAXLEN, "Storage communicator process");
	snprintf(bgw.bgw_type, BGW_MAXLEN, "Storage communicator process");
	bgw.bgw_restart_time = 5;
	bgw.bgw_notify_pid = 0;
	bgw.bgw_main_arg = (Datum) 0;

	RegisterBackgroundWorker(&bgw);

	SpinLockInit(&in_elog);
}

static size_t
communicator_new_shmem_size(void)
{
	size_t		size = 0;

	size += MAXALIGN(
		offsetof(CommunicatorShmemData, io_completion_latches) +
		MaxProcs * sizeof(Latch)
		);

	/* space needed by the rust code */
	size += rcommunicator_shmem_size(MaxProcs);

	return size;
}

void
communicator_new_shmem_request(void)
{
	RequestAddinShmemSpace(communicator_new_shmem_size());
}

void
communicator_new_shmem_startup(void)
{
	bool		found;
	int			pipefd[2];
	int			rc;
	size_t		communicator_size;
	size_t		shmem_size;
	void	   *shmem_ptr;

	rc = pipe(pipefd);
	if (rc != 0)
		ereport(ERROR,
				(errcode_for_file_access(),
				 errmsg_internal("could not create pipe between neon communicator and backends : %m")));
	if (fcntl(pipefd[0], F_SETFL, O_NONBLOCK) == -1)
		elog(FATAL, "fcntl(F_SETFL) failed on read-end of communicator pipe: %m");
	if (fcntl(pipefd[1], F_SETFL, O_NONBLOCK) == -1)
		elog(FATAL, "fcntl(F_SETFL) failed on write-end of communicator pipe: %m");

	shmem_size = communicator_new_shmem_size();
	shmem_ptr = ShmemInitStruct("Communicator shmem state",
								shmem_size,
								&found);
	Assert(!found);

	/* Initialize the C-managed parts */
	communicator_shmem_ptr = (CommunicatorShmemData *) shmem_ptr;
	communicator_size = MAXALIGN(offsetof(CommunicatorShmemData, io_completion_latches) + MaxProcs * sizeof(Latch));
	shmem_ptr = (char *) shmem_ptr + communicator_size;
	shmem_size -= communicator_size;

	for (int i = 0; i < MaxProcs; i++)
	{
		InitSharedLatch(&communicator_shmem_ptr->io_completion_latches[i]);
	}

	/* Initialize the rust-managed parts */
	cis = rcommunicator_shmem_init(pipefd[0], pipefd[1], MaxProcs, shmem_ptr, shmem_size);
}

/**** Worker process functions. These run in the communicator worker process ****/

/* Entry point for the communicator bgworker process */
void
communicator_new_bgworker_main(Datum main_arg)
{
	char	  **connstrs;
	shardno_t	num_shards;
	struct LoggingState *logging;
	char		errbuf[1000];
	int			elevel;

	/* Establish signal handlers. */
	pqsignal(SIGUSR1, procsignal_sigusr1_handler);
	pqsignal(SIGHUP, SignalHandlerForConfigReload);
	pqsignal(SIGTERM, die);

	BackgroundWorkerUnblockSignals();

	get_shard_map(&connstrs, &num_shards);

	logging = configure_logging();

	communicator_worker_process_launch(
		cis,
		neon_tenant,
		neon_timeline,
		neon_auth_token,
		connstrs,
		num_shards
		);

	elog(LOG, "communicator threads started");
	for (;;)
	{
		int32		rc;

		CHECK_FOR_INTERRUPTS();

		for (;;) {
			rc = pump_logging(logging, (uint8 *) errbuf, sizeof(errbuf), &elevel);
			if (rc == 0)
			{
				/* nothing to do */
				break;
			}
			else if (rc == 1)
			{
				/* Because we don't want to exit on error */
				if (elevel == ERROR)
					elevel = LOG;
				if (elevel == INFO)
					elevel = LOG;
				elog(elevel, "[COMMUNICATOR] %s", errbuf);
			}
			else if (rc == -1)
			{
				elog(ERROR, "logging channel was closed unexpectedly");
			}
		}

		(void) WaitLatch(MyIOCompletionLatch,
						 WL_LATCH_SET | WL_EXIT_ON_PM_DEATH,
						 0,
						 PG_WAIT_EXTENSION);
		ResetLatch(MyIOCompletionLatch);
	}
}

/*
 * Callbacks from the rust code, in the communicator process.
 *
 * NOTE: These must be thread safe! It's very limited which PostgreSQL functions you can use!!!
 *
 * NOTE: the signatures of these better match the Rust definitions!
 */

void
notify_proc_unsafe(int procno)
{
	SetLatch(&communicator_shmem_ptr->io_completion_latches[procno]);
}

void
callback_set_my_latch_unsafe(void)
{
	SetLatch(MyLatch);
}

/**** Backend functions. These run in each backend ****/

/* Initialize per-backend private state */
void
communicator_new_init(void)
{
	Assert(cis != NULL);
	Assert(my_bs == NULL);

	OwnLatch(MyIOCompletionLatch);

	my_bs = rcommunicator_backend_init(cis, MyProcNumber);

	/*
	 * Arrange to clean up at backend exit.
	 */
	on_shmem_exit(communicator_new_backend_exit, 0);
}

static void
communicator_new_backend_exit(int code, Datum arg)
{
	DisownLatch(MyIOCompletionLatch);
}

/*
 * Lookup of already received prefetch requests. Only already received
 * responses matching required LSNs are accepted.  Present pages are marked in
 * "mask" bitmap and total number of such pages is returned.
 */
int
communicator_new_prefetch_lookupv(NRelFileInfo rinfo, ForkNumber forkNum, BlockNumber blocknum,
								  neon_request_lsns *lsns, BlockNumber nblocks,
								  void **buffers, bits8 *mask)
{
	/* TODO */
	return 0;
}

/*
 * prefetch_register_bufferv() - register and prefetch buffers
 *
 * Register that we may want the contents of BufferTag in the near future.
 * This is used when issuing a speculative prefetch request, but also when
 * performing a synchronous request and need the buffer right now.
 *
 * If force_request_lsns is not NULL, those values are sent to the
 * pageserver. If NULL, we utilize the lastWrittenLsn -infrastructure
 * to calculate the LSNs to send.
 *
 * Bits set in *mask (if present) indicate pages already read; i.e. pages we
 * can skip in this process.
 *
 * When performing a prefetch rather than a synchronous request,
 * is_prefetch==true. Currently, it only affects how the request is accounted
 * in the perf counters.
 *
 * NOTE: this function may indirectly update MyPState->pfs_hash; which
 * invalidates any active pointers into the hash table.
 */
void
communicator_new_prefetch_register_bufferv(BufferTag tag, neon_request_lsns *frlsns,
										   BlockNumber nblocks, const bits8 *mask)
{
	/* TODO */
	elog(LOG, "communicator_new_prefetch_register_bufferv not implemented");
}

/*
 * Perform an IO request in a synchronous fashion.
 *
 * Returns a pointer to the result slot. It is valid until the next time a
 * request is submitted.
 */
static const NeonIOResult *
perform_request(NeonIORequest *request)
{
	int32_t		request_idx;
	int32_t		poll_res;
	const NeonIOResult *result;

	for (;;)
	{
		ResetLatch(MyIOCompletionLatch);

		CHECK_FOR_INTERRUPTS();

		request_idx = bcomm_start_io_request(my_bs, request);
		// fixme: check 'request_idx' ?

		elog(DEBUG5, "sent request with idx %d: tag %d", request_idx, request->tag);

		/*
		 * TODO: wake up periodically for CHECK_FOR_INTERRUPTS(). Because we wait on
		 * MyIOCompletionLatch rather than MyLatch, we won't be woken up for the standard
		 * interrupts.
		 */
		(void) WaitLatch(MyIOCompletionLatch,
						 WL_EXIT_ON_PM_DEATH | WL_LATCH_SET,
						 0,
						 WAIT_EVENT_NEON_PS_STARTING);

		poll_res = bcomm_poll_request_completion(my_bs, request_idx, &result);
		if (poll_res == -1)
			continue; /* still busy */
		else if (poll_res == 0)
			return result;
		else
		{
			// FIXME: better error message
			elog(ERROR, "request failed");
		}
	}
}

/*
 *	Does the physical file exist?
 */
bool
communicator_new_rel_exists(NRelFileInfo rinfo, ForkNumber forkNum, neon_request_lsns *request_lsns)
{
	NeonIORequest request = {
		.tag = NeonIORequest_RelExists,
		.rel_exists = {
			.spc_oid = NInfoGetSpcOid(rinfo),
			.db_oid = NInfoGetDbOid(rinfo),
			.rel_number = NInfoGetRelNumber(rinfo),
			.fork_number = forkNum,
			.request_lsn = request_lsns->request_lsn,
			.not_modified_since_lsn = request_lsns->not_modified_since,
		}
	};
	const NeonIOResult *result;

	result = perform_request(&request);
	Assert(result->tag == NeonIOResult_RelExists);

	return result->rel_exists;
}

static void
communicator_new_read_at_lsn(NRelFileInfo rinfo, ForkNumber forkNum, BlockNumber blockno,
							  neon_request_lsns *request_lsns,
							  void *buffer)
{
	/*
	 * FIXME: if 'buffer' points to local memory rather than a shared memory
	 * area, we need a different way of getting the result from the
	 * communicator.
	 */

	NeonIORequest request = {
		.tag = NeonIORequest_GetPage,
		.get_page = {
			.spc_oid = NInfoGetSpcOid(rinfo),
			.db_oid = NInfoGetDbOid(rinfo),
			.rel_number = NInfoGetRelNumber(rinfo),
			.fork_number = forkNum,
			.block_number = blockno,
			.request_lsn = request_lsns->request_lsn,
			.not_modified_since = request_lsns->not_modified_since,
			.dest_ptr = (uintptr_t) buffer,
			.dest_size = BLCKSZ,
		}
	};
	const NeonIOResult *result;

	result = perform_request(&request);
	Assert(result->tag == NeonIOResult_GetPage);
}

/*
 * Read N pages at a specific LSN.
 *
 * *mask is set for pages read at a previous point in time, and which we
 * should not touch, nor overwrite.
 * New bits should be set in *mask for the pages we'successfully read.
 *
 * The offsets in request_lsns, buffers, and mask are linked.
 */
void
communicator_new_read_at_lsnv(NRelFileInfo rinfo, ForkNumber forkNum, BlockNumber base_blockno,
							  neon_request_lsns *request_lsnsv,
							  void **buffers, BlockNumber nblocks, const bits8 *mask)
{
	for (uint32 i = 0; i < nblocks; i++)
	{
		if (PointerIsValid(mask) && !BITMAP_ISSET(mask, i))
			continue;

		communicator_new_read_at_lsn(rinfo,
									 forkNum,
									 base_blockno + i,
									 &request_lsnsv[i],
									 buffers[i]);
	}
}

/*
 *	neon_nblocks() -- Get the number of blocks stored in a relation.
 */
BlockNumber
communicator_new_rel_nblocks(NRelFileInfo rinfo, ForkNumber forkNum, neon_request_lsns *request_lsns)
{
	NeonIORequest request = {
		.tag = NeonIORequest_RelSize,
		.rel_size = {
			.spc_oid = NInfoGetSpcOid(rinfo),
			.db_oid = NInfoGetDbOid(rinfo),
			.rel_number = NInfoGetRelNumber(rinfo),
			.fork_number = forkNum,
			.request_lsn = request_lsns->request_lsn,
			.not_modified_since = request_lsns->not_modified_since,
		}
	};
	const NeonIOResult *result;

	result = perform_request(&request);
	Assert(result->tag == NeonIOResult_RelSize);

	return result->rel_size;
}

/*
 *	neon_db_size() -- Get the size of the database in bytes.
 */
int64
communicator_new_dbsize(Oid dbNode, neon_request_lsns *request_lsns)
{
	NeonIORequest request = {
		.tag = NeonIORequest_DbSize,
		.db_size = {
			.db_oid = dbNode,
			.request_lsn = request_lsns->request_lsn,
			.not_modified_since = request_lsns->not_modified_since,
		}
	};
	const NeonIOResult *result;

	result = perform_request(&request);
	Assert(result->tag == NeonIOResult_DbSize);

	return (int64) result->db_size;
}

int
communicator_new_read_slru_segment(SlruKind kind, int64 segno, neon_request_lsns *request_lsns,
								   void *buffer)
{
	/* TODO */
	elog(ERROR, "not implemented");
}
